# 가상기억장치의 개요
가상기억장치는 보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법이다.
- 프로그램을 여러 개의 작은 블록 단위로 나누어서 가상기억장치에 보관해 놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리한다.
- 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용한다.
- 주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있다.
- 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환작업이 필요하다.
- 블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수 있다.
- 가상기억장치의 일반적인 구현 방법에는 블록의 종류에 따라 페이징 기법과 세그먼테이션 기법으로 나눌 수 있다.

<br>
<br>
<br>
<br>

## Paging
페이징 기법은 가상기억장치에 보관되어 있는 프로그램과 주 기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법이다.
- 프로그램을 일정한 크기로 나눈 단위를 페이지(Page)라고 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임(Page Frame)이라고 한다.
- 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다.
- 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 Page Map Table이 필요하다.
- Page Map Table 사용으로 비용이 증가되고, 처리 속도가 감소된다.

<br>
<br>
<br>
<br>

## Segmentation

<br>

**Segmentation의 개요**   
세그먼테이션 기법은 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법이다.
- 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖는다.
- 기억장치의 사용자 관점을 보존하는 기억장치 관리 기법이다.
- 세그먼테이션 기법을 이용하는 궁극적인 이유는 기억공간을 절약하기 위해서이다.
- 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 가지고 있는 Segment Map Table이 필요하다.
- 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 기억장치 보호기(Storage Protection Key)가 필요하다.
- 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있다.

<br>
<br>

**세그먼테이션 기법의 일반적인 주소 변환**   
- 주소형식에 따른 주소와 세그먼트 맵 테이블의 구성
- 가상주소는 세그먼트 번호를 나타내는 s와 세그먼트 내에 실제 내용이 위치하고 있는 곳까지의 거리를 나타내는 변위값 d로 구성된다.
- 실기억주소는 완전주소 형태를 사용하며 이는 세그먼트의 기준번지와 변위값을 더함으로써 얻을 수 있다.
- Segment Map Table은 세그먼트 번호 s와 세그먼트의 크기 L(한계번지), 주기억장치 상의 기준번지(시작주소)b로 구성된다.

<br>

**주소 변환 순서**   
1. 가상주소의 세그먼트 번호로 세그먼트 맵테이블에서 해당 세그번트의 기준번지와 세그먼트 크기를 구한다. 세그먼트 번호는 세그먼트 맵 테이블에 대한 색인으로 사용된다.
2. 가상주소와 변위값과 세그먼트의 크기를 비교한다.
3. 변위값이 작거나 같으면 기준번지와 변위값을 더하여 실기억주소를 만들어 주기억장치를 액세스한다.
4. 변위값이 크면 다른 영역을 침범하게 되므로 실행 권한을 운영체제에게 넘기고 트랩을 발생시킨다(변위값이 크다는 것은 현재 찾는 세그먼트의 위치가 해당 세그먼트의 크기(한계번지)를 초과하였다는 의미이다).

<br>
<br>
<br>
<br>

## 페이지 교체 알고리즘
페이지 교체 알고리즘은 페이지 부재(Page Fault)가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주 기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법이다.
- 페이지 교체 알고리즘에는 OPT, FIFO, LRU, LFU, NUR, SCR 등이 있다.

<br>

**OPT(OPTimal replacement, 최적 교체)**   
- OPT는 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법이다.
- 벨레이디가 제안한 것으로, 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘이다.

<br>

**FIFO(First In First Out)**   
- FIFO는 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법이다.
- 이해하기 쉽고, 프로그래밍 설계가 간단하다.

<br>

**LRU(Least Recent Used)**   
- LRU는 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법이다.
- 각 페이지마다 계수기(Counter)나 Stack을 두어 현 시점에서 가장 오랫동안 사용하지 않은, 즉 가장 오래 전에 사용된 페이지를 교체한다.

<br>

**LFU(Lease Frequently Used)**   
- LFU는 사용 빈도가 가장 적은 페이지를 교체하는 기법이다.
- 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용된다.

<br>

**NUR(Not Used Recently)**   
- NUR은 LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법이다.
- 최근에 사용되지 않은 페이지는 향후에도 사용되지 않을 가능성이 높다는 것을 전제로, LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있다.
- 최근의 사용 여부를 확인하기 위해서 각 페이지마다 두 개의 비트, 즉 참조 비트(Reference Bit)와 변형 비트(Modified Bit, Dirty Bit)가 사용된다.

```
Reference Bit
페이지가 호출되지 않았을 때는 0, 호출되었을 때는 1로 지정

Modified Bit, Dirty Bit
페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때는 1로 지정
```

<br>

**SCR(Second Chance Replacement, 2차 기회 교체)**   
SCR은 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보완하는 기법이다.

